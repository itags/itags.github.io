<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/itags.core/itags.core.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/BaseClass.html">BaseClass</a></li>
            
                <li><a href="../classes/Classes.html">Classes</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/Dialog.html">Dialog</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/HTMLElement.html">HTMLElement</a></li>
            
                <li><a href="../classes/Icons.html">Icons</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ItagBaseClass.html">ItagBaseClass</a></li>
            
                <li><a href="../classes/itagCore.html">itagCore</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Messages.html">Messages</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NodePlugin.html">NodePlugin</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Panel.html">Panel</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/Promise.Resolver.html">Promise.Resolver</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/dialog.html">dialog</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-blurnode.html">event-blurnode</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-focusnode.html">event-focusnode</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/extra_classes.js.html">extra/classes.js</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/icons.html">icons</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itags.core.html">itags.core</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/messages.html">messages</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-plugin.html">node-plugin</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/panel.html">panel</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/itags.core/itags.core.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jshint proto:true */

/**
 * Provides several methods that override native Element-methods to work with the vdom.
 *
 *
 * &lt;i&gt;Copyright (c) 2015 ITSA - https://github.com/itags&lt;/i&gt;
 * &lt;br&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 * @module itags.core
 * @class itagCore
 * @since 0.0.1
*/


&quot;use strict&quot;;

require(&#x27;./css/itags.core.css&#x27;);

var NAME = &#x27;[itags.core]: &#x27;,
    ITSA = require(&#x27;itsa&#x27;),
    createHashMap = ITSA.createHashMap,
    async = ITSA.async,
    Event = ITSA.Event,
    Classes = ITSA.Classes,
    CLASS_ITAG_RENDERED = &#x27;itag-rendered&#x27;,
    DEFAULT_CHAIN_INIT = true,
    DEFAULT_CHAIN_DESTROY = true,
    NODE = &#x27;node&#x27;,
    REMOVE = &#x27;remove&#x27;,
    INSERT = &#x27;insert&#x27;,
    CHANGE = &#x27;change&#x27;,
    ATTRIBUTE = &#x27;attribute&#x27;,
    NODE_REMOVE = NODE+REMOVE,
    NODE_INSERT = NODE+INSERT,
    NODE_CONTENT_CHANGE = NODE+&#x27;content&#x27;+CHANGE,
    ATTRIBUTE_REMOVE = ATTRIBUTE+REMOVE,
    ATTRIBUTE_CHANGE = ATTRIBUTE+CHANGE,
    ATTRIBUTE_INSERT = ATTRIBUTE+INSERT,
    /**
     * Internal hash containing the names of members which names should be transformed
     *
     * @property ITAG_METHODS
     * @default {init: &#x27;_initUI&#x27;, sync: &#x27;_syncUI&#x27;, destroy: &#x27;_destroyUI&#x27;, attrs: &#x27;_attrs&#x27;}
     * @type Object
     * @protected
     * @since 0.0.1
    */
    ITAG_METHODS = createHashMap({
        init: &#x27;_initUI&#x27;,
        render: &#x27;_renderUI&#x27;,
        sync: &#x27;_syncUI&#x27;,
        destroy: &#x27;_destroyUI&#x27;,
        attrs: &#x27;_attrs&#x27;
    }),
    // ITAG_METHOD_VALUES must match previous ITAG_METHODS&#x27;s values!
    ITAG_METHOD_VALUES = createHashMap({
        _initUI: true,
        _renderUI: true,
        _syncUI: true,
        _destroyUI: true,
        _attrs: true
    }),
    NOOP = function() {};

module.exports = function (window) {
    // make ITSA available as global, so we can use it in all other itag-modules:
    window.ITSA = ITSA;

    var DOCUMENT = window.document,
        PROTOTYPE_CHAIN_CAN_BE_SET = arguments[1], // hidden feature, used by unit-test
        RUNNING_ON_NODE = (typeof global !== &#x27;undefined&#x27;) &amp;&amp; (global.window!==window),
        PROTO_SUPPORTED = !!Object.__proto__,
        BINDING_LIST = {},
        itagCore, PROTECTED_MEMBERS, EXTRA_BASE_MEMBERS,
        ATTRIBUTE_EVENTS, manageFocus, mergeFlat;


/*jshint boss:true */
    if (itagCore=window._ItagCore) {
/*jshint boss:false */
        return itagCore; // itagCore was already defined
    }

    /**
     * Internal hash containing all ITAG-Class definitions.
     *
     * @property ITAGS
     * @type Object
     * @for window
     * @since 0.0.1
    */
    Object.protectedProp(window, &#x27;ITAGS&#x27;, {}); // for the ProtoConstructors

    /**
     * Base properties for every Itag-class
     *
     *
     * @property EXTRA_BASE_MEMBERS
     * @type Object
     * @protected
     * @for ItagBaseClass
     * @since 0.0.1
    */
    EXTRA_BASE_MEMBERS = {
       /**
        * Calls &#x60;_destroyUI&#x60; on through the class-chain on every level (bottom-up).
        * _destroyUI gets defined when the itag defines &#x60;destroy&#x60; --&gt; transformation under the hood.
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method destroyUI
        * @param constructor {Class} the Class which belongs with the itag
        * @param [reInitialize=false] {Boolean} whether the destruction comes from a &#x60;re-initialize&#x60;-call. For internal usage.
        * @chainable
        * @since 0.0.1
        */
        destroyUI: function(constructor, reInitialize) {
            var instance = this,
                vnode = instance.vnode,
                superDestroy, observer;
            if (vnode.ce_initialized &amp;&amp; (reInitialize || vnode.removedFromDOM) &amp;&amp; !vnode.ce_destroyed) {
                if (!reInitialize) {
                    observer = instance.getData(&#x27;_observer&#x27;);
                    instance.model.unobserve(observer);
                    instance.removeData(&#x27;_observer&#x27;);
                }
                superDestroy = function(constructor) {
                    var classCarierBKP = instance.__classCarier__;
                    // don&#x27;t call &#x60;hasOwnProperty&#x60; directly on obj --&gt; it might have been overruled
                    Object.prototype.hasOwnProperty.call(constructor.prototype, &#x27;_destroyUI&#x27;) &amp;&amp; constructor.prototype._destroyUI.call(instance);
                    if (constructor.$$chainDestroyed) {
                        instance.__classCarier__ = constructor.$$super.constructor;
                        superDestroy(constructor.$$super.constructor);
                    }
                    classCarierBKP = instance.__classCarier__;
                };
                superDestroy(constructor || instance.constructor);
                itagCore.destroyPlugins(instance);
                instance.detachAll();
                // DO NOT set model to null --&gt; it might be refered to asynchronously
                // We don&#x27;t need to bother: the node gets out of the dom and will really be destroyed after
                // 1 minute: because no-one needs it, the GC should clean up model when no longer needed
            }
            reInitialize || Object.protectedProp(vnode, &#x27;ce_destroyed&#x27;, true);
            return instance;
        },

       /**
        * Unitializer for itags. Calls the &#x60;_init&#x60;-method through the whole chain (top-bottom).
        * _initUI() is set for each &#x60;init&#x60;-member --&gt; transformed under the hood.
        *
        * @method initUI
        * @param constructor {Class} the Class which belongs with the itag
        * @param [reInitialize=false] {Boolean} whether the initialization comes from a &#x60;re-initialize&#x60;-call. For internal usage.
        * @chainable
        * @since 0.0.1
        */
        initUI: function(constructor, reInitialize) {
            var instance = this,
                vnode = instance.vnode,
                superInit, serverModel;
            if ((reInitialize || !vnode.ce_initialized) &amp;&amp; !vnode.removedFromDOM &amp;&amp; !vnode.ce_destroyed) {
                superInit = function(constructor) {
                    var classCarierBKP = instance.__classCarier__;
                    if (constructor.$$chainInited) {
                        instance.__classCarier__ = constructor.$$super.constructor;
                        superInit(constructor.$$super.constructor);
                    }
                    classCarierBKP = instance.__classCarier__;
                    // don&#x27;t call &#x60;hasOwnProperty&#x60; directly on obj --&gt; it might have been overruled
                    Object.prototype.hasOwnProperty.call(constructor.prototype, &#x27;_initUI&#x27;) &amp;&amp; constructor.prototype._initUI.call(instance);
                };
                if (!reInitialize) {
                    // First time init.
                    // If already rendered on the server:
                    // bind the stored json-data on the property &#x60;model&#x60;:
                    if (instance.hasClass(CLASS_ITAG_RENDERED)) {
                        // already rendered on the server
                        if (!RUNNING_ON_NODE) {
                            serverModel = itagCore.extractModel(instance);
                            if (serverModel &amp;&amp; !vnode.ce_boundModel) {
                                instance.model = serverModel;
                            }
                        }
                        Object.protectedProp(vnode, &#x27;ce_designNode&#x27;, itagCore.extractContent(instance));
                    }
                    else {
                        Object.protectedProp(vnode, &#x27;ce_designNode&#x27;, itagCore.extractContent(instance, true));
                    }
                }
                superInit(constructor || instance.constructor);
                // because inside &#x60;init&#x60; model-props might have been set --&gt; these should be refelcted in the dom:
                itagCore.modelToAttrs(instance);
            }
            return instance;
        },

       /**
        * Does the one-time initial rendering: is succeeded with syncUI
        *
        * @method renderUI
        * @param [reInitialize=false] {Boolean} whether the renderUI comes from a &#x60;re-initialize&#x60;-call. For internal usage.
        * @chainable
        * @since 0.0.1
        */
        renderUI: function(reInitialize) {
            var instance = this,
                vnode = instance.vnode;
            if ((reInitialize || !vnode.ce_initialized) &amp;&amp; !vnode.removedFromDOM &amp;&amp; !vnode.ce_destroyed) {
                instance._renderUI();
                itagCore.initPlugins(instance);
                Object.protectedProp(vnode, &#x27;ce_initialized&#x27;, true);
            }
            return instance;
        },

        getItagContainer: function() {
            return this.vnode.ce_designNode;
        },

       /**
        * Flag that tells wether the itag is rendered. If you need to wait for rendering (to continue processing),
        * then use &#x60;itagReady()&#x60;
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method isRendered
        * @return {Boolean} whether the itag is rendered.
        * @since 0.0.1
        */
        isRendered: function() {
            return !!this.getData(&#x27;itagRendered&#x27;);
        },

       /**
        * Flag that tells wether the itag is destoyed.
        *
        * @method isDestroyed
        * @return {Boolean} whether the itag is destroyed.
        * @since 0.0.1
        */
        isDestroyed: function() {
            return !!this.vnode.ce_destroyed;
        },

       /**
        * Promise that gets fulfilled as soon as the itag is rendered.
        *
        * @method itagReady
        * @return {Promise} fulfilled when rendered for the first time.
        * @since 0.0.1
        */
        itagReady: function() {
            var instance = this;
            if (!instance.isItag()) {
                console.warn(&#x27;itagReady() invoked on a non-itag element&#x27;);
                return window.Promise.reject(&#x27;Element is no itag&#x27;);
            }
            instance._itagReady || (instance._itagReady=window.Promise.manage());
            return instance._itagReady;
        },

       /**
        * Destroys and reinitialises the itag-element.
        * No need to use directly, only internal.
        *
        * @method reInitializeUI
        * @param constructor {Class} the Class which belongs with the itag
        * @chainable
        * @since 0.0.1
        */
        reInitializeUI: function(constructor) {
            var instance = this,
                vnode = instance.vnode;
            if (vnode.ce_initialized &amp;&amp; !vnode.removedFromDOM &amp;&amp; !vnode.ce_destroyed) {
                instance.destroyUI(constructor, true)
                        .initUI(constructor, true)
                        .renderUI(true)
                        .syncUI();
            }
            return instance;
        },

       /**
        * Defines the &#x60;key&#x60;-property on element.model, but only when is hasn&#x27;t been defined before.
        *
        * @method defineWhenUndefined
        * @chainable
        * @since 0.0.1
        */
        defineWhenUndefined: function(key, value) {
            var model = this.model;
            if (value!==undefined) {
                model.hasKey(key) || (model[key]=value);
            }
            return this;
        },

       /**
        * Syncs the itag, by calling &#x60;_syncUI&#x60;: the transformed &#x60;sync()&#x60;-method.
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method syncUI
        * @chainable
        * @since 0.0.1
        */
        syncUI: function() {
            var instance = this,
                attrs = instance._attrs,
                vnode = instance.vnode,
                stringifiedData, vChildNodes, lastVChild;
            if (vnode.ce_initialized &amp;&amp; !vnode.removedFromDOM &amp;&amp; !vnode.ce_destroyed) {
                vnode._setUnchangableAttrs(attrs);
                instance._syncUI.apply(instance, arguments);
                vnode._setUnchangableAttrs(null);
                if (RUNNING_ON_NODE) {
                    // store the modeldata inside a commentNode at the end of innerHTML:
                    try {
                        stringifiedData = JSON.stringify(instance.model);
                        // we need to patch directly on the vnode --&gt; modification of commentNodes
                        // have no customized methods on the Element, but they are patchable through Element.vnode:
                        vChildNodes = vnode.vChildNodes;
                        lastVChild = vChildNodes[vChildNodes.length-1];
                        if (lastVChild &amp;&amp; (lastVChild.nodeType===8) &amp;&amp; (lastVChild.text.startsWith(&#x27;i-model:{&#x27;))) {
                            // modeldata was already set --&gt; overwrite it
                            lastVChild.text = &#x27;i-model:&#x27;+stringifiedData;
                            // lastVChild.domNode.nodeValue = unescapeEntities(lastVChild.text);
                            lastVChild.domNode.nodeValue = lastVChild.text;
                        }
                        else {
                            // insert modeldata
                            instance.prepend(&#x27;&lt;!--i-model:&#x27;+stringifiedData+&#x27;--&gt;&#x27;);
                        }
                    }
                    catch(e) {
                        console.warn(e);
                    }
                }
            }
            return instance;
        },

        contentHidden: true,

       /**
        * Invoked after a model is bound. Can be used for further action.
        * Not always need to: after this method, &#x60;sync&#x60; will get invoked.
        *
        * @method _afterBindModel
        * @private
        * @chainable
        * @since 0.0.1
        */
        _afterBindModel: NOOP,

        /**
         * Internal hash containing the &#x60;attrs&#x60;-definition which can be set by the itag-declaration.
         * This hash is used to determine which properties of &#x60;model&#x60; need to sync as an attribute.
         *
         * @property _attrs
         * @default {}
         * @type Object
         * @private
         * @since 0.0.1
        */
        _attrs: {},

       /**
        * Transformed from &#x60;destroy&#x60; --&gt; when &#x60;destroy&#x60; gets invoked, the instance will invoke &#x60;_destroyUI&#x60; through the whole chain.
        * Defaults to &#x60;NOOP&#x60;, so that it can be always be invoked.
        *
        * @method _destroyUI
        * @private
        * @chainable
        * @since 0.0.1
        */
        _destroyUI: NOOP,

       /**
        * Transformed from &#x60;init&#x60; --&gt; when the instance gets created, the instance will invoke &#x60;_initUI&#x60; through the whole chain.
        * Defaults to &#x60;NOOP&#x60;, so that it can be always be invoked.
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method _initUI
        * @private
        * @since 0.0.1
        */
        _initUI: NOOP,

       /**
        * Transformed from &#x60;render&#x60; --&gt; when the instance gets created, the instance will invoke &#x60;_renderUI&#x60; through the whole chain.
        * Defaults to &#x60;NOOP&#x60;, so that it can be always be invoked.
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method _renderUI
        * @private
        * @since 0.0.1
        */
        _renderUI: NOOP,

       /**
        * Transformed from &#x60;sync&#x60; --&gt; when &#x60;sync&#x60; gets invoked, the instance will invoke &#x60;_syncUI&#x60;.
        * Defaults to &#x60;NOOP&#x60;, so that it can be always be invoked.
        *
        * @method _syncUI
        * @private
        * @since 0.0.1
        */
        _syncUI: NOOP
    };

    EXTRA_BASE_MEMBERS.merge(Event.Listener)
                      .merge(Event._CE_listener);

    /**
     * Internal hash holding all attribute-mutation events
     *
     * @property ATTRIBUTE_EVENTS
     * @default [&#x27;attributeremove&#x27;, &#x27;attributechange&#x27;, &#x27;attributeinsert&#x27;]
     * @type Array
     * @protected
     * @since 0.0.1
    */
    ATTRIBUTE_EVENTS = [ATTRIBUTE_REMOVE, ATTRIBUTE_CHANGE, ATTRIBUTE_INSERT];

    /**
     * Internal hash containing all &#x60;protected members&#x60; --&gt; the properties that CANNOT be set at the prototype of ItagClasses.
     *
     * @property PROTECTED_MEMBERS
     * @default {
     *    bindModel: true,
     *    destroyUI: true,
     *    initUI: true,
     *    isRendered: true,
     *    reInitializeUI: true,
     *    syncUI: true
     * }
     * @type Object
     * @private
     * @since 0.0.1
    */
    PROTECTED_MEMBERS = createHashMap();
    EXTRA_BASE_MEMBERS.each(function(value, key) {
        ITAG_METHOD_VALUES[key] || (key===&#x27;_afterBindModel&#x27;) || (key===&#x27;itagReady&#x27;) || (PROTECTED_MEMBERS[key] = true);
    });

   /**
    * Merges all prototype-members of every level in the chain directly on the domElement.
    * This needs to be done for browsers which don&#x27;t support changing __proto__ (like &lt;IE11)
    *
    * @method mergeFlat
    * @param constructor {Class} the Class which belongs with the itag, holding all the members
    * @param domElement {HTMLElement} the Element that recieves the members
    * @private
    * @since 0.0.1
    */
    mergeFlat = function(constructor, domElement) {
        var prototype = constructor.prototype,
            keys, i, name, propDescriptor;
        if (domElement.__addedProps__) {
            // set before: erase previous properties
            domElement.__addedProps__.each(function(value, key) {
                delete domElement[key];
            });
        }
        domElement.__addedProps__ = {};
        while (prototype !== window.HTMLElement.prototype) {
            keys = Object.getOwnPropertyNames(prototype);
/*jshint boss:true */
            for (i=0; name=keys[i]; i++) {
/*jshint boss:false */
                if (!domElement.__addedProps__[name]) {
                    propDescriptor = Object.getOwnPropertyDescriptor(prototype, name);
                    propDescriptor.configurable = true;
                    // needs configurable, otherwise we cannot delete it when refreshing
                    Object.defineProperty(domElement, name, propDescriptor);
                    domElement.__addedProps__[name] = true;
                }
            }
            constructor = constructor.$$super.constructor;
            prototype = constructor.prototype;
        }
    };

    itagCore = {

        initPlugins: function(domElement) {
            var processVChildNodes = function(vnode) {
                var vChildren = vnode.vChildren,
                    len = vChildren.length,
                    i, vChild, attrs, ns, j, len2, keys, attribute;
                for (i=0; i&lt;len; i++) {
                    vChild = vChildren[i];
/*jshint boss:true */
                    if (attrs=vChild.attrs) {
/*jshint boss:false */
                        keys = attrs.keys();
                        len2 = keys.length;
                        for (j=0; j&lt;len2; j++) {
                            attribute = keys[j];
                            if ((attribute.substr(0, 7)===&#x27;plugin-&#x27;) &amp;&amp; (attrs[attribute]===&#x27;true&#x27;)) {
                                ns = attribute.substr(7);
                                vChild.domNode.plug(ns);
                            }
                        }
                    }
                    processVChildNodes(vChild);
                }
            };
            processVChildNodes(domElement.vnode);
        },

        destroyPlugins: function(domElement) {
            var processVChildNodes = function(vnode) {
                var vChildren = vnode.vChildren,
                    len = vChildren.length,
                    i, vChild, j, len2, ns, keys, plugin;
                for (i=0; i&lt;len; i++) {
                    vChild = vChildren[i];
/*jshint boss:true */
                    if (plugin=vChild.domNode.plugin) {
/*jshint boss:false */
                        keys = plugin.keys();
                        len2 = keys.length;
                        for (j=0; j&lt;len2; j++) {
                            ns = keys[j];
                            vChild.domNode.unplug(ns);
                        }
                    }
                    processVChildNodes(vChild);
                }
            };
            processVChildNodes(domElement.vnode);
        },

       /**
        * Copies the attibute-values into element.model.
        * Only processes the attributes that are defined through the Itag-class its &#x60;attrs&#x60;-property.
        *
        * @method attrsToModel
        * @param domElement {HTMLElement} the itag that should be processed.
        * @for itagCore
        * @since 0.0.1
        */
        attrsToModel: function(domElement) {
            console.log(NAME+&#x27;attrsToModel&#x27;);
            var attrs = domElement._attrs,
                attrValue, validValue;
            attrs.each(function(value, key) {
                attrValue = domElement.getAttr(key);
                if (attrValue) {
                    switch (value.toLowerCase()) {
                        case &#x27;boolean&#x27;:
                            validValue = attrValue.validateBoolean();
                            attrValue = (attrValue===&#x27;true&#x27;);
                            break;
                        case &#x27;number&#x27;:
                            validValue = attrValue.validateFloat();
                            attrValue = parseFloat(attrValue);
                            break;
                        case &#x27;date&#x27;:
                            validValue = attrValue.validateDate();
                            attrValue = attrValue.toDate();
                            break;
                        case &#x27;string&#x27;:
                            validValue = true;
                            break;
                        default:
                            validValue = false;
                    }
                }
                else if (value.toLowerCase()===&#x27;boolean&#x27;) {
                    // undefined &#x60;boolean&#x60; attributes need to be stored as &#x60;false&#x60;
                    validValue = true;
                    attrValue = false;
                }
                else {
                    validValue = false;
                }
                validValue &amp;&amp; domElement.defineWhenUndefined(key, attrValue);
            });
        },

       /**
        * Binds a model to the itag-element, making element.model equals the bound model.
        * Immediately syncs the itag with the new model-data.
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method bindModel
        * @param element {HTMLElement} element, which should be an Itag
        * @param model {Object} the model to bind to the itag-element
        * @param [mergeCurrent=false] {Boolean} when set true, current properties on the iTag&#x27;s model that aren&#x27;t defined
        *        in the new model, get merged into the new model.
        *        NOTE: ItagClasses with &#x60;setLazyBinding&#x60; set &#x60;true&#x60; will merge by default, unless other specified
        * @since 0.0.1
        */
        bindModel: function(element, model, mergeCurrent) {
            console.log(NAME+&#x27;bindModel&#x27;);
            var instance = this,
                observer;
            if (element.isItag() &amp;&amp; (element.model!==model) &amp;&amp; !element.inside(&#x27;.ce-design-node&#x27;)) {
                element.removeAttr(&#x27;lazybind&#x27;);
                Object.protectedProp(element.vnode, &#x27;ce_boundModel&#x27;, true);
                observer = element.getData(&#x27;_observer&#x27;);
                element.model.unobserve(observer);
                if (mergeCurrent || (element.lazyBind &amp;&amp; (mergeCurrent!==false))) {
                    model.merge(element.model, {full: true});
                }
                element.model = model;
                observer = function() {
                    itagCore.modelToAttrs(element);
                    element.syncUI();
                };
                element.model.observe(observer);
                element.setData(&#x27;_observer&#x27;, observer);
                if (!element.vnode.ce_initialized) {
                    instance.attrsToModel(element);
                    element.initUI(PROTO_SUPPORTED ? null : element.__proto__.constructor)
                           .renderUI();
                }
                element._afterBindModel();
                element.syncUI();
                element.itagRendered || instance.setRendered(element);
            }
        },

       /**
        * Retrieves modeldata set by the server inside the itag-element and binds this data into element.model
        *
        * @method extractModel
        * @param domElement {HTMLElement} the itag that should be processed.
        * @return {Object|null} the modeldata or null when not supplied
        * @since 0.0.1
        */
        extractModel: function(domElement) {
            console.log(NAME+&#x27;extractModel&#x27;);
            var vnode = domElement.vnode,
                vChildNodes = vnode.vChildNodes,
                lastPos = vChildNodes.length - 1,
                i = -1,
                modelData, vChildNode, content;
            // walk through the vChilds and handle the model-data:
            while ((++i&lt;lastPos) &amp;&amp; (modelData===undefined)) {
                vChildNode = vChildNodes[i];
                if ((vChildNode.nodeType===8) &amp;&amp; (vChildNode.text.startsWith(&#x27;i-model:{&#x27;))) {
                    // modeldata was set
                    try {
                        content = vChildNode.text.replaceAll(&#x27;&amp;lt;&#x27;, &#x27;&lt;&#x27;).replaceAll(&#x27;&amp;gt;&#x27;, &#x27;&gt;&#x27;);
                        modelData = JSON.parseWithDate(content.substr(8));
                    }
                    catch(e) {
                        modelData = null;
                        console.warn(e);
                    }
                    vnode._removeChild(vChildNode);
                }
            }
            return modelData || null;
        },

       /**
        * Retrieves content set by the definition of the iTag. The content should be inside a comment-node
        * inside the itag. The returnvalue is a container-node (DIV) where the content
        * -as is specified by the comment-node- lies within as true HTML.
        *
        * @method extractContent
        * @param domElement {HTMLElement} the itag that should be processed.
        * @return {HTMLElement} a DIV-container with HTML inside
        * @since 0.0.1
        */
        extractContent: function(domElement, empty) {
            console.log(NAME+&#x27;extractContent&#x27;);
            var vnode = domElement.vnode,
                vChildNodes = vnode.vChildNodes,
                lastPos = vChildNodes.length,
                i = -1,
                container = DOCUMENT.createElement(&#x27;div&#x27;),
                content, vChildNode;
            // mark the container with a class --&gt;
            // so we know we don&#x27;t need to render the itags anything inside:
            container.setClass(&#x27;ce-design-node&#x27;);
            // walk through the vChilds and handle the model-data:
            while ((++i&lt;lastPos) &amp;&amp; !content) {
                vChildNode = vChildNodes[i];
                if ((vChildNode.nodeType===8) &amp;&amp; (!vChildNode.text.startsWith(&#x27;i-model:{&#x27;))) {
                    content = vChildNode.text.trim().replaceAll(&#x27;&amp;lt;&#x27;, &#x27;&lt;&#x27;).replaceAll(&#x27;&amp;gt;&#x27;, &#x27;&gt;&#x27;);
                    // to support nested comments (in case of nested iTags),
                    // we transform any text looking like --!&gt; into --&gt;
                    content = content.replaceAll(&#x27;&lt;!==&#x27;, &#x27;&lt;!--&#x27;).replaceAll(&#x27;==&gt;&#x27;, &#x27;--&gt;&#x27;);
                    container.vnode.setHTML(content, true);
                    empty || vnode._removeChild(vChildNode);
                }
            }
            empty &amp;&amp; domElement.empty();
            return container;
        },

       /**
        * Function that can be used ad the &#x60;filterFn&#x60; of event-listeners.
        * Returns true for any HTML-element that is a rendered itag.
        *
        * @method itagFilter
        * @param e {Object} the event-object passed by Event
        * @return {Boolean} whether the HTML-element that is a rendered itag
        * @since 0.0.1
        */
        itagFilter: function(e) {
            console.log(NAME+&#x27;itagFilter&#x27;);
            var node = e.target;
            return node.vnode.isItag &amp;&amp; node.getData(&#x27;itagRendered&#x27;);
        },

       /**
        * Copies elemtn.model values into the attibute-values of the element.
        * Only processes the attributes that are defined through the Itag-class its &#x60;attrs&#x60;-property.
        *
        * @method modelToAttrs
        * @param domElement {HTMLElement} the itag that should be processed.
        * @since 0.0.1
        */
        modelToAttrs: function(domElement) {
            console.log(NAME+&#x27;modelToAttrs&#x27;);
            var attrs = domElement._attrs,
                model = domElement.model,
                newAttrs = [];
            attrs.each(function(value, key) {
                model.hasKey(key) &amp;&amp; (newAttrs[newAttrs.length] = {name: key, value: model[key]});
            });
            (newAttrs.length&gt;0) &amp;&amp; domElement.setAttrs(newAttrs, true);
        },

       /**
        * Searches through the dom for the specified itags and upgrades its HTMLElement.
        *
        * @method renderDomElements
        * @param domElementConstructor {Class} the Class which belongs with the itag
        * @since 0.0.1
        */
        renderDomElements: function(domElementConstructor) {
            console.log(NAME+&#x27;renderDomElements&#x27;);
            var itagName = domElementConstructor.$$itag,
                pseudo = domElementConstructor.$$pseudo,
                itagElements = pseudo ? DOCUMENT.getAll(itagName+&#x27;[is=&quot;&#x27;+pseudo+&#x27;&quot;]&#x27;) : DOCUMENT.getAll(itagName+&#x27;:not([is])&#x27;),
                len = itagElements.length,
                i, itagElement;
            for (i=0; i&lt;len; i++) {
                itagElement = itagElements[i];
                this.upgradeElement(itagElement, domElementConstructor);
            }
        },

       /**
        * Defines the itag-element as being rendered.
        *
        * @method setRendered
        * @param domElement {HTMLElement} the itag that should be processed.
        * @since 0.0.1
        */
        setRendered: function(domElement) {
            console.log(NAME+&#x27;setRendered&#x27;);
            domElement.setClass(CLASS_ITAG_RENDERED, null, null, true);
            domElement.setData(&#x27;itagRendered&#x27;, true);
            domElement._itagReady || (domElement._itagReady=window.Promise.manage());
            domElement._itagReady.fulfill();
        },

       /**
        * Sets up all general itag-emitters.
        *
        * @method setupEmitters
        * @since 0.0.1
        */
        setupEmitters: function() {
            console.log(NAME+&#x27;setupEmitters&#x27;);
            Event.after(&#x27;*:&#x27;+NODE_CONTENT_CHANGE, function(e) {
                var element = e.target;
                /**
                * Emitted when an itag changed its content
                *
                * @event *:change
                * @param e {Object} eventobject including:
                * @param e.target {HtmlElement} the dropzone
                * @since 0.1
                */
                element.emit(&#x27;change&#x27;, {model: element.model});
            }, this.itagFilter);
        },

        setContentVisibility: function(ItagClass, value) {
            console.log(NAME+&#x27;setContentVisibility&#x27;);
            (typeof value === &#x27;boolean&#x27;) &amp;&amp; ItagClass.mergePrototypes({contentHidden: !value}, true, false, true);
        },

        setLazyBinding: function(ItagClass, value) {
            console.log(NAME+&#x27;setLazyBinding&#x27;);
            (typeof value === &#x27;boolean&#x27;) &amp;&amp; ItagClass.mergePrototypes({lazyBind: !value}, true, false, true);
        },

       /**
        * Sets up all itag-watchers, giving itags its life behaviour.
        *
        * @method setupWatchers
        * @since 0.0.1
        */
        setupWatchers: function() {
            console.log(NAME+&#x27;setupWatchers&#x27;);

            Event.after(
                &#x27;UI:&#x27;+NODE_REMOVE,
                function(e) {
                    var node = e.target;
                    node.destroyUI(PROTO_SUPPORTED ? null : node.__proto__.constructor);
                },
                itagCore.itagFilter
            );

            Event.before(
                &#x27;*:manualfocus&#x27;,
                function(e) {
                    var node = e.target;
                    if (!node.isRendered()) {
                        e.halt();
                        node.itagReady().then(
                            function() {
                                // re-emit the focus
                                node.focus();
                            }
                        );
                    }
                },
                function(e) {
                    return e.target.vnode.isItag;
                }
            );

            if (PROTO_SUPPORTED) {
                Event.after(
                    &#x27;*:prototypechange&#x27;,
                    function(e) {
                        var prototypes = e.prototypes,
                            ItagClass = e.target,
                            nodeList, node, i, length;
                        if (&#x27;init&#x27; in prototypes) {
                            nodeList = DOCUMENT.getAll(ItagClass.$$itag+&#x27;.&#x27;+CLASS_ITAG_RENDERED, true);
                            length = nodeList.length;
                            for (i=0; i&lt;length; i++) {
                                node = nodeList[i];
                                node.reInitializeUI();
                            }
                        }
                        else if (&#x27;sync&#x27; in prototypes) {
                            nodeList = DOCUMENT.getAll(ItagClass.$$itag+&#x27;.&#x27;+CLASS_ITAG_RENDERED, true);
                            length = nodeList.length;
                            for (i=0; i&lt;length; i++) {
                                node = nodeList[i];
                                node.syncUI();
                            }
                        }
                    },
                    function(e) {
                        return !!e.target.$$itag;
                    }
                );
                Event.after(
                    &#x27;*:prototyperemove&#x27;,
                    function(e) {
                        var properties = e.properties,
                            ItagClass = e.target,
                            nodeList, node, i, length;
                        if (properties.contains(&#x27;init&#x27;)) {
                            nodeList = DOCUMENT.getAll(ItagClass.$$itag+&#x27;.&#x27;+CLASS_ITAG_RENDERED, true);
                            length = nodeList.length;
                            for (i=0; i&lt;length; i++) {
                                node = nodeList[i];
                                node.reInitializeUI();
                            }
                        }
                        else if (properties.contains(&#x27;sync&#x27;)) {
                            nodeList = DOCUMENT.getAll(ItagClass.$$itag+&#x27;.&#x27;+CLASS_ITAG_RENDERED, true);
                            length = nodeList.length;
                            for (i=0; i&lt;length; i++) {
                                node = nodeList[i];
                                node.syncUI();
                            }
                        }
                    },
                    function(e) {
                        return !!e.target.$$itag;
                    }
                );
            }
        },

       /**
        * Upgrades the HTMLElement into an itag defined by domElementConstructor.
        *
        * @method upgradeElement
        * @param domElement {HTMLElement} the itag that should be processed.
        * @param domElementConstructor {Class} the Class which belongs with the itag
        * @since 0.0.1
        */
        upgradeElement: function(domElement, domElementConstructor) {
            console.log(NAME+&#x27;upgradeElement&#x27;);
            var instance = this,
                proto = domElementConstructor.prototype,
                observer;
            domElement.model || (domElement.model={});
            if (!PROTO_SUPPORTED) {
                mergeFlat(domElementConstructor, domElement);
                domElement.__proto__ = proto;
                domElement.__classCarier__ = domElementConstructor;
                domElement.after(
                    &#x27;*:prototypechange&#x27;,
                    function(e) {
                        var prototypes = e.prototypes;
                        mergeFlat(domElementConstructor, domElement);
                        if (&#x27;init&#x27; in prototypes) {
                            domElement.reInitializeUI(domElement.__proto__.constructor);
                        }
                        else if (&#x27;sync&#x27; in prototypes) {
                            domElement.syncUI();
                        }
                    },
                    function(e) {
                        return !!e.target.$$itag;
                    }
                );
                domElement.after(
                    &#x27;*:prototyperemove&#x27;,
                    function(e) {
                        var properties = e.properties;
                        mergeFlat(domElementConstructor, domElement);
                        if (properties.contains(&#x27;init&#x27;)) {
                            domElement.reInitializeUI(domElement.__proto__.constructor);
                        }
                        else if (properties.contains(&#x27;sync&#x27;)) {
                            domElement.syncUI();
                        }
                    },
                    function(e) {
                        return !!e.target.$$itag;
                    }
                );
            }
            else {
                domElement.__proto__ = proto;
                domElement.__classCarier__ = domElementConstructor;
            }
            // sync, but do this after the element is created:
            // in the next eventcycle:
            async(function(){
                var needsToBind = domElement.lazyBind || (domElement.getAttr(&#x27;lazybind&#x27;)===&#x27;true&#x27;);
                // only if no modelbinding is needed, we can directly init, sync and make ready,
                // otherwise we need to make this done by  &#x60;bindModel&#x60;
                BINDING_LIST.some(function(value, selector) {
                    domElement.matches(selector) &amp;&amp; (needsToBind=true);
                    return needsToBind;
                });
                if (!needsToBind) {
                    instance.attrsToModel(domElement);
                    domElement.initUI(PROTO_SUPPORTED ? null : domElementConstructor)
                              .renderUI()
                              .syncUI();
                    instance.setRendered(domElement);
                }
                observer = function() {
                    instance.modelToAttrs(domElement);
                    domElement.syncUI();
                };
                domElement.model.observe(observer);
                domElement.setData(&#x27;_observer&#x27;, observer);
            });
        }
    };

   /**
    * Resets the focus on the right element inside an itag-instance after syncing.
    * Only when a focusmanager is active and has focus.
    *
    * @method manageFocus
    * @param domElement {Element} The itag to be inspected
    * @private
    * @since 0.0.1
    */
    manageFocus = function(domElement) {
        console.log(NAME+&#x27;manageFocus&#x27;);
        var focusManagerNode = domElement.getElement(&#x27;.focussed[fm-manage]&#x27;);
        focusManagerNode &amp;&amp; focusManagerNode.focus();
    };

   /**
    * Reference to the original document.createElement.
    *
    * @method _createElement
    * @param tag {String} tagname to be created
    * @private
    * @return {HTMLElement}
    * @for document
    * @since 0.0.1
    */
    DOCUMENT._createElement = DOCUMENT.createElement;

   /**
    * Binds a model to the itag-element, making element.model equals the bound model.
    * Immediately syncs the itag with the new model-data.
    *
    * Syncs the new vnode&#x27;s childNodes with the dom.
    *
    * @method bindModel
    * @param model {Object} the model to bind to the itag-element
    * @param selector {String|HTMLElement} a css-selector or an HTMLElement where the data should be bound
    * @param [mergeCurrent=false] {Boolean} when set true, current properties on the iTag that aren&#x27;t defined
    *                                       in the new model, get merged into the new model.
    *        NOTE: ItagClasses with &#x60;setLazyBinding&#x60; set &#x60;true&#x60; will merge by default, unless other specified
    * @param [fineGrain] {Function} A function that recieves &#x60;model&#x60; as argument and should return a
    *                               manipulated (subset) of model as new model to be bound
    * @return {Object} handler with a &#x60;detach()&#x60;-method which can be used to detach the binder
    * @since 0.0.1
    */
    DOCUMENT.bindModel = function(model, selector, mergeCurrent, fineGrain) {
        console.log(NAME+&#x27;bindModel&#x27;);
        var documentElement = DOCUMENT.documentElement,
            listener, elements, observer;
        if ((typeof selector === &#x27;string&#x27;) &amp;&amp; (selector.length&gt;0) &amp;&amp; !BINDING_LIST[selector]) {
            BINDING_LIST[selector] = true;
            elements = documentElement.getAll(selector);
            elements.forEach(function(element) {
                itagCore.bindModel(element, (typeof fineGrain===&#x27;function&#x27;) ? fineGrain(element, model) : model, mergeCurrent);
            });
            listener = Event.after(&#x27;UI:&#x27;+NODE_INSERT, function(e) {
                var element = e.target;
                itagCore.bindModel(element, (typeof fineGrain===&#x27;function&#x27;) ? fineGrain(element, model) : model, mergeCurrent);
            }, function(e) {
                return e.target.matches(selector);
            });
            return {
                detach: function() {
                    listener.detach();
                    elements = documentElement.getAll(selector);
                    elements.forEach(function(element) {
                        observer = element.getData(&#x27;_observer&#x27;);
                        element.model.unobserve(observer);
                    });
                    delete BINDING_LIST[selector];
                }
            };
        }
        // else
        return {
            detach: function() {
                if (typeof selector === &#x27;string&#x27;) {
                    delete BINDING_LIST[selector];
                }
            }
        };
    };

   /**
    * Redefinition of document.createElement, enabling creation of itags.
    *
    * @method createElement
    * @param tag {String} tagname to be created
    * @param [suppressItagRender] {Boolean} to suppress Itags from rendering
    * @return {HTMLElement}
    * @since 0.0.1
    */
    DOCUMENT.createElement = function(tag, suppressItagRender) {
        console.log(NAME+&#x27;createElement &#x27;+tag);
        var ItagClass = window.ITAGS[tag.toLowerCase()],
            pos;
        if (!suppressItagRender &amp;&amp; ItagClass) {
            return new ItagClass();
        }
        // we could run into a situation where we have an itag that is a pseudoclass
        // yet suppressItagRender is &#x60;true&#x60;. This would lead into tagnames like: I-BUTTON#reset
        // because native createElement cannot create these, we need to strip as from the #
        else if (ItagClass &amp;&amp; ((pos=tag.indexOf(&#x27;#&#x27;))!==-1)) {
            tag = tag.substr(0, pos);
        }
        return DOCUMENT._createElement(tag);
    };

    /**
     * Internal hash containing all DOM-events that are listened for (at &#x60;document&#x60;).
     *
     *
     * @property defineItag
     * @param itagName {String} The name of the itag-element, starting with &#x60;i-&#x60;
     * @param [prototypes] {Object} Hash map of properties to be added to the prototype of the new class.
     * @param [subClassable=true] {Boolean} whether the Class is subclassable. Can only be set to false on ItagClasses
     * @type Class
     * @for document
     * @since 0.0.1
    */
    Object.protectedProp(DOCUMENT, &#x27;defineItag&#x27;, function(itagName, prototypes, subClassable) {
        return Classes.ItagBaseClass.subClass.call(Classes.ItagBaseClass, itagName, prototypes, null, null, subClassable);
    });

    //===============================================================================
    //== patching native prototypes =================================================
    (function(FunctionPrototype) {
        var originalSubClass = FunctionPrototype.subClass;
       /**
         * Backup of the original &#x60;mergePrototypes&#x60;-method.
         *
         * @method mergePrototypes
         * @param prototypes {Object} Hash prototypes of properties to add to the prototype of this object
         * @param force {Boolean}  If true, existing members will be overwritten
         * @private
         * @chainable
         * @since 0.0.1
        */
        FunctionPrototype._mergePrototypes = FunctionPrototype.mergePrototypes;

       /**
         * Merges the given prototypes of properties into the &#x60;prototype&#x60; of the Class.
         *
         * **Note1 ** to be used on instances --&gt; ONLY on Classes
         * **Note2 ** properties with getters and/or unwritable will NOT be merged
         *
         * The members in the hash prototypes will become members with
         * instances of the merged class.
         *
         * By default, this method will not override existing prototype members,
         * unless the second argument &#x60;force&#x60; is true.
         *
         * In case of merging properties into an itag, a &#x60;*:prototypechange&#x60;-event gets emitted
         *
         * @method mergePrototypes
         * @param prototypes {Object} Hash prototypes of properties to add to the prototype of this object
         * @param [force=false] {Boolean}  If true, existing members will be overwritten
         * @param [silent=false] {Boolean}  If true, no &#x60;*:prototypechange&#x60; event will get emitted
         * @chainable
         * @since 0.0.1
        */
        FunctionPrototype.mergePrototypes = function(prototypes, force, silent) {
            var instance = this,
                overwriteProtected = arguments[3], // hidden private feature
                itagEmitterName;
            if (!instance.$$itag) {
                // default mergePrototypes
                instance._mergePrototypes(prototypes, force);
            }
            else {
                instance._mergePrototypes(prototypes, force, ITAG_METHODS, overwriteProtected ? null : PROTECTED_MEMBERS);
                /**
                * Emitted when prototypes are set on an existing Itag-Class.
                *
                * @event *:prototypechange
                * @param e {Object} eventobject including:
                * @param e.prototypes {Object} Hash prototypes of properties to add to the prototype of this object
                * @param e.force {Boolean} whether existing members are overwritten
                * @since 0.1
                */
                if (!silent) {
                    // cannot emit on the instance
                    itagEmitterName = instance.$$itag + (instance.$$pseudo ? &#x27;#&#x27;+instance.$$pseudo : &#x27;&#x27;);
                    Event.emit(instance, itagEmitterName+&#x27;:prototypechange&#x27;, {prototypes: prototypes, force: !!force});
                }
            }
            return instance;
        };

       /**
        * Subclasses in Itag-Class into a pseudo-class: retaining its tagname, yet still subclassing.
        * The pseudoclass gets identified by &#x60;i-parentclass#pseudo&#x60; and once rendered it has the signature of:
        * &amp;lt;i-parentclass&amp;gt; is=&quot;pseudo&quot; &amp;lt;/i-parentclass&amp;gt;
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method pseudoClass
        * @param pseudo {String} The pseudoname (without a minustoken), leading into the definition of &#x60;i-parent:pseudo&#x60;
        * @param [prototypes] {Object} Hash map of properties to be added to the prototype of the new class.
        * @param [chainInit=true] {Boolean} Whether -during instance creation- to automaticly construct in the complete hierarchy with the given constructor arguments.
        * @param [chainDestroy=true] {Boolean} Whether -when the Element gets out if the DOM- to automaticly destroy in the complete hierarchy.
        * @param [subClassable=true] {Boolean} whether the Class is subclassable. Can only be set to false on ItagClasses
        * @return {Class}
        * @since 0.0.1
        */
        FunctionPrototype.pseudoClass = function(pseudo, prototypes, chainInit, chainDestroy, subClassable) {
            var instance = this;
            if (!instance.$$itag) {
                console.warn(NAME, &#x27;cannot pseudoClass &#x27;+pseudo+&#x27; for its Parent is no Itag-Class&#x27;);
                return instance;
            }
            if (typeof pseudo !== &#x27;string&#x27;) {
                console.warn(NAME, &#x27;cannot pseudoClass --&gt; first argument needs to be s String&#x27;);
                return instance;
            }
            if (pseudo.contains(&#x27;-&#x27;)) {
                console.warn(NAME, &#x27;cannot pseudoClass &#x27;+pseudo+&#x27; --&gt; name cannot consist a minus-token&#x27;);
                return instance;
            }
            return instance.subClass(instance.$$itag+&#x27;#&#x27;+pseudo , prototypes, chainInit, chainDestroy, subClassable);
        };

       /**
        * Backup of the original &#x60;removePrototypes&#x60;-method.
        *
        * @method _removePrototypes
        * @param properties
        * @private
        * @chainable
        * @since 0.0.1
        */
        FunctionPrototype._removePrototypes = FunctionPrototype.removePrototypes;

       /**
        * Redefines the childNodes of both the vnode as well as its related dom-node. The new
        * definition replaces any previous nodes. (without touching unmodified nodes).
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method removePrototypes
        * @param properties
        * @chainable
        * @since 0.0.1
        */
        FunctionPrototype.removePrototypes = function(properties, silent) {
            var instance = this,
                itagEmitterName;
            if (!instance.$$itag) {
                // default mergePrototypes
                instance._removePrototypes.apply(instance, arguments);
            }
            else {
                instance._removePrototypes(properties, ITAG_METHODS);
                /**
                * Emitted when prototypes are removed off an existing Itag-Class.
                *
                * @event *:prototyperemove
                * @param e {Object} eventobject including:
                * @param e.prototypes {Object} Hash prototypes of properties to add to the prototype of this object
                * @since 0.1
                */

                if (!silent) {
                    // cannot emit on the instance
                    itagEmitterName = instance.$$itag + (instance.$$pseudo ? &#x27;#&#x27;+instance.$$pseudo : &#x27;&#x27;);
                    Event.emit(instance, itagEmitterName+&#x27;:prototyperemove&#x27;, {properties: properties});
                }
                instance.prototype.emit(&#x27;prototyperemove&#x27;, {properties: properties});
            }
            return instance;
        };


       /**
        * Backup of the original &#x60;setConstructor&#x60;-method.
        *
        * @method _setConstructor
        * @param [constructorFn] {Function} The function that will serve as the new constructor for the class.
        *        If &#x60;undefined&#x60; defaults to &#x60;NOOP&#x60;
        * @param [prototypes] {Object} Hash map of properties to be added to the prototype of the new class.
        * @param [chainConstruct=true] {Boolean} Whether -during instance creation- to automaticly construct in the complete hierarchy with the given constructor arguments.
        * @chainable
        * @since 0.0.1
        */
        FunctionPrototype._setConstructor = FunctionPrototype.setConstructor;

        /**
         * Redefines the constructor fo the Class
         *
         * @method setConstructor
         * @param [constructorFn] {Function} The function that will serve as the new constructor for the class.
         *        If &#x60;undefined&#x60; defaults to &#x60;NOOP&#x60;
         * @param [prototypes] {Object} Hash map of properties to be added to the prototype of the new class.
         * @param [chainConstruct=true] {Boolean} Whether -during instance creation- to automaticly construct in the complete hierarchy with the given constructor arguments.
         * @chainable
         */
        FunctionPrototype.setConstructor = function(/* constructorFn, chainConstruct */) {
            var instance = this;
            if (instance.$$itag) {
                console.warn(NAME, &#x27;Itags don\t have a constructor --&gt; you need to redefine &quot;init()&quot; by using mergePrototypes()&#x27;);
                return instance;
            }
            return instance._setConstructor.apply(instance, arguments);
        };

       /**
        * Redefines the childNodes of both the vnode as well as its related dom-node. The new
        * definition replaces any previous nodes. (without touching unmodified nodes).
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method subClass
        * @param [constructorOrItagname] {Function|String} The function that will serve as constructor for the new class.
        *        If &#x60;undefined&#x60; defaults to &#x60;NOOP&#x60;
        *        When subClassing an ItagClass, a String should be passed as first argument
        * @param [prototypes] {Object} Hash map of properties to be added to the prototype of the new class.
        * @param [chainInit=true] {Boolean} Whether -during instance creation- to automaticly construct in the complete hierarchy with the given constructor arguments.
        * @param [chainDestroy=true] {Boolean} Whether -when the Element gets out if the DOM- to automaticly destroy in the complete hierarchy.
        * @param [subClassable=true] {Boolean} whether the Class is subclassable. Can only be set to false on ItagClasses
        * @return {Class}
        * @since 0.0.1
        */
        FunctionPrototype.subClass = function(constructorOrItagname, prototypes, chainInit, chainDestroy, subClassable) {
            var instance = this,
                baseProt, proto, domElementConstructor, itagName, pseudo, registerName, itagNameSplit, itagEmitterName;
            if (typeof constructorOrItagname === &#x27;string&#x27;) {
                // Itag subclassing
                if (typeof prototypes === &#x27;boolean&#x27;) {
                    subClassable = chainDestroy;
                    chainDestroy = chainInit;
                    chainInit = prototypes;
                    prototypes = null;
                }
                (typeof chainInit === &#x27;boolean&#x27;) || (chainInit=DEFAULT_CHAIN_INIT);
                (typeof chainDestroy === &#x27;boolean&#x27;) || (chainDestroy=DEFAULT_CHAIN_DESTROY);
                (typeof subClassable === &#x27;boolean&#x27;) || (subClassable=true);

                itagName = constructorOrItagname.toLowerCase();
                if (!itagName.startsWith(&#x27;i-&#x27;)) {
                    console.warn(NAME, &#x27;invalid itagname &#x27;+itagName+&#x27; --&gt; name should start with i-&#x27;);
                    return instance;
                }
                if (window.ITAGS[itagName]) {
                    console.warn(itagName+&#x27; already exists: it will be redefined&#x27;);
                }
                registerName = itagName;
                itagNameSplit = itagName.split(&#x27;#&#x27;);
                itagName = itagNameSplit[0];
                pseudo = itagNameSplit[1]; // may be undefined

                if (instance.$$itag &amp;&amp; !instance.$$subClassable &amp;&amp; !pseudo) {
                    console.warn(NAME, instance.$$itag+&#x27; cannot be sub-classed&#x27;);
                    return instance;
                }

                // if instance.isItag, then we subclass an existing i-tag
                baseProt = instance.prototype;
                proto = Object.create(baseProt);

                // merge some system function in case they don&#x27;t exists
                domElementConstructor = function() {
                    var domElement = DOCUMENT._createElement(itagName);
                    pseudo &amp;&amp; domElement.vnode._setAttr(&#x27;is&#x27;, pseudo, true);
                    itagCore.upgradeElement(domElement, domElementConstructor);
                    return domElement;
                };

                domElementConstructor.prototype = proto;

                // webkit doesn&#x27;t let all objects to have their constructor redefined
                // when directly assigned. Using &#x60;defineProperty will work:
                Object.defineProperty(proto, &#x27;constructor&#x27;, {value: domElementConstructor});

                domElementConstructor.$$itag = itagName;
                domElementConstructor.$$pseudo = pseudo;
                domElementConstructor.$$chainInited = chainInit ? true : false;
                domElementConstructor.$$chainDestroyed = chainDestroy ? true : false;
                domElementConstructor.$$super = baseProt;
                domElementConstructor.$$orig = {};
                domElementConstructor.$$subClassable = subClassable;

                itagEmitterName = itagName + (pseudo ? &#x27;#&#x27;+pseudo : &#x27;&#x27;);
                domElementConstructor.mergePrototypes(Event.Emitter(itagEmitterName), true, true);
                prototypes &amp;&amp; domElementConstructor.mergePrototypes(prototypes, true, true);
                // make emitting change-events unpreventable and unrenderable:
                Event.defineEvent(itagEmitterName+&#x27;:change&#x27;).unPreventable();
                Event.defineEvent(itagEmitterName+&#x27;:prototypechange&#x27;).unPreventable();
                Event.defineEvent(itagEmitterName+&#x27;:prototyperemove&#x27;).unPreventable();

                window.ITAGS[registerName] = domElementConstructor;

                itagCore.renderDomElements(domElementConstructor);

                return domElementConstructor;
            }
            else {
                // Function subclassing
                if (instance.$$itag) {
                    console.warn(NAME, &#x27;subClassing &#x27;+instance.$$itag+&#x27; needs a &quot;String&quot; as first argument&#x27;);
                    return instance;
                }
                return originalSubClass.apply(instance, arguments);
            }
        };

    }(Function.prototype));

    (function(ElementPrototype) {
        var setAttributeBKP = ElementPrototype.setAttribute,
            removeAttributeBKP = ElementPrototype.removeAttribute;

       /**
        * Binds a model to the itag-element, making element.model equals the bound model.
        * Immediately syncs the itag with the new model-data.
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method bindModel
        * @param model {Object} the model to bind to the itag-element
        * @param [mergeCurrent=false] {Boolean} when set true, current properties on the iTag that aren&#x27;t defined
        *                                       in the new model, get merged into the new model.
        *        NOTE: ItagClasses with &#x60;setLazyBinding&#x60; set &#x60;true&#x60; will merge by default, unless other specified
        * @param [fineGrain] {Function} A function that recieves &#x60;model&#x60; as argument and should return a
        *                               manipulated (subset) of model as new model to be bound
        * @return {Object} handler with a &#x60;detach()&#x60;-method which can be used to detach the binder
        * @since 0.0.1
        */
        ElementPrototype.bindModel = function(model, mergeCurrent, fineGrain) {
            var instance = this,
                observer;
            if (instance._syncUI) {
                itagCore.bindModel(instance, (typeof fineGrain===&#x27;function&#x27;) ? fineGrain(instance, model) : model, mergeCurrent);
                return {
                    detach: function() {
                        observer = instance.getData(&#x27;_observer&#x27;);
                        instance.model.unobserve(observer);
                    }
                };
            }
            // else for compatabilaty, return a detachFn
            return {
                detach: function() {}
            };
        };

       /**
        * Removes the attribute from the Element.
        * In case of an Itag --&gt; will remove the property of element.model
        *
        * Use removeAttr() to be able to chain.
        *
        * @method removeAttr
        * @param attributeName {String}
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @since 0.0.1
        */
        ElementPrototype.removeAttribute = function(attributeName, silent) {
            var instance = this;
            if (!instance.isItag() || silent) {
                removeAttributeBKP.apply(instance, arguments);
            }
            else {
                if (instance._attrs[attributeName]) {
                    delete instance.model[attributeName];
                }
                else {
                    removeAttributeBKP.apply(instance, arguments);
                }
            }
        };

       /**
         * Sets the attribute on the Element with the specified value.
        * In case of an Itag --&gt; will remove the property of element.model
         *
         * Alias for setAttr(), BUT differs in a way that setAttr is chainable, setAttribute is not.
         *
         * @method setAttribute
         * @param attributeName {String}
         * @param value {String} the value for the attributeName
         * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
         * @since 0.0.1
        */
        ElementPrototype.setAttribute = function(attributeName, value, silent) {
            var instance = this,
                valueType;
            if (!instance.isItag() || silent) {
                setAttributeBKP.apply(instance, arguments);
            }
            else {
/*jshint boss:true */
                if (instance._attrs &amp;&amp; (valueType=instance._attrs[attributeName])) {
/*jshint boss:false */
                    switch (valueType.toLowerCase()) {
                        case &#x27;boolean&#x27;:
                            value = (value===&#x27;true&#x27;);
                            break;
                        case &#x27;number&#x27;:
                            value = parseFloat(value);
                            break;
                        case &#x27;date&#x27;:
                            value = value.toDate();
                            break;
                    }
                    instance.model[attributeName] = value;
                }
                else {
                    setAttributeBKP.apply(instance, arguments);
                }
            }
        };
    }(window.Element.prototype));

    (function(HTMLElementPrototype) {
       /**
        * Flag that tells whether the HTMLElement is an Itag
        *
        * @method isItag
        * @return {Boolean}
        * @for HTMLElement
        * @since 0.0.1
        */
        HTMLElementPrototype.isItag = function() {
            return this.vnode.isItag;
        };

    }(window.HTMLElement.prototype));

    //===============================================================================

   /**
    * Creates the base ItagClass: the highest Class in the hierarchy of all ItagClasses.
    * Will get extra properties merge into its prototype, which leads into the formation of &#x60;ItagBaseClass&#x60;.
    *
    * @method createItagBaseClass
    * @protected
    * @return {Class}
    * @for itagCore
    * @since 0.0.1
    */
    var createItagBaseClass = function () {
        return Function.prototype.subClass.apply(window.HTMLElement);
    };

    /**
     * The base ItagClass: the highest Class in the hierarchy of all ItagClasses.
     *
     * @property ItagBaseClass
     * @type Class
     * @for Classes
     * @since 0.0.1
    */
    Object.protectedProp(Classes, &#x27;ItagBaseClass&#x27;, createItagBaseClass().mergePrototypes(EXTRA_BASE_MEMBERS, true, {}, {}));

    // because &#x60;mergePrototypes&#x60; cannot merge object-getters, we will add the getter &#x60;$super&#x60; manually:
    Object.defineProperties(Classes.ItagBaseClass.prototype, Classes.coreMethods);

    /**
     * Calculated value of the specified member at the parent-Class.
     *
     * @method $superProp
     * @return {Any}
     * @for ItagBaseClass
     * @since 0.0.1
    */
    Object.defineProperty(Classes.ItagBaseClass.prototype, &#x27;$superProp&#x27;, {
        value: function(/* member, *args */) {
            var instance = this,
                classCarierReturn = instance.__$superCarierStart__ || instance.__classCarier__ || instance.__methodClassCarier__,
                currentClassCarier = instance.__classCarier__ || instance.__methodClassCarier__,
                args = arguments,
                superClass, superPrototype, firstArg, returnValue;

            instance.__$superCarierStart__ = null;
            if (args.length === 0) {
                instance.__classCarier__ = classCarierReturn;
                return;
            }

            superClass = currentClassCarier.$$super.constructor,
            superPrototype = superClass.prototype,
            firstArg = Array.prototype.shift.apply(args); // will decrease the length of args with one
            firstArg = ITAG_METHODS[firstArg] || firstArg;
            (firstArg === &#x27;_initUI&#x27;) &amp;&amp; (firstArg=&#x27;initUI&#x27;); // to re-initiate chaining
            (firstArg === &#x27;_destroyUI&#x27;) &amp;&amp; (firstArg=&#x27;destroyUI&#x27;); // to re-initiate chaining
            if ((firstArg===&#x27;initUI&#x27;) &amp;&amp; currentClassCarier.$$chainInited) {
                console.warn(&#x27;init cannot be invoked manually, because the Class is &#x60;chainInited&#x60;&#x27;);
                return currentClassCarier;
            }

            if ((firstArg===&#x27;destroyUI&#x27;) &amp;&amp; currentClassCarier.$$chainDestroyed) {
                console.warn(&#x27;destroy cannot be invoked manually, because the Class is &#x60;chainDestroyed&#x60;&#x27;);
                return currentClassCarier;
            }

            if (typeof superPrototype[firstArg] === &#x27;function&#x27;) {
                instance.__classCarier__ = superClass;
                if ((firstArg===&#x27;initUI&#x27;) || (firstArg===&#x27;destroyUI&#x27;)) {
                    returnValue = superPrototype[firstArg].call(instance, instance.__classCarier__);
                }
                else {
                    returnValue = superPrototype[firstArg].apply(instance, args);
                }
            }
            instance.__classCarier__ = classCarierReturn;
            return returnValue || superPrototype[firstArg];
        }
    });

    itagCore.setupWatchers();
    itagCore.setupEmitters();

    Object.protectedProp(window, &#x27;_ItagCore&#x27;, itagCore);

    if (PROTOTYPE_CHAIN_CAN_BE_SET) {
       /*
        * Only for usage during testing --&gt; can deactivate the usage of __proto__ making the itags
        * upgraded my merging all ItagClass-members to the domElement-instance.
        *
        * @method setPrototypeChain
        * @param activate
        * @for itagCore
        * @since 0.0.1
        */
        itagCore.setPrototypeChain = function(activate) {
            PROTO_SUPPORTED = activate ? !!Object.__proto__ : false;
        };
    }

    return itagCore;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
